||||| FullStack Python

1| 15. Models - 4 (Clase 24)
1| 16. Django: Admin - 1 (Clase 26)
1| 17. Personalizando el Django Admin y relaciones muchos a muchos con tabular inline (Clase 27)
1| 18. Django Authentication  Autenticación y autorización desde Django (Clase 28)
1| 19. Django: Rest Framework (Clase 31)
1| 20. Django: Despliegue (Clase 32)




-----------------------
----------------------- 
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 16. Django: Admin - 1 (Clase 26)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Admin - 1
    ● Que es el DjangoAdmin
    ● Configuración del DjangoAdmin
    ● Creación del superusuario
    ● Integrando modelos al DjangoAdmin

----------------------- ¿Qué es el Django Admin?
Una de las partes más poderosas de Django es la interfaz de 
administración automática. Lee los metadatos de los modelos para 
proporcionar una interfaz rápida y centrada en el modelo donde los 
usuarios de confianza pueden administrar el contenido de su sitio. La 
herramienta se encuentra enfocada en la administración interna del 
sistema por parte de un administrador pero no está pensada para el 
usuario final. Su intención no es armar un front-end completo de 
administración

* Está integrada y la podemos sacar si es necesario.


----------------------- Configurable
<IMAGEN> img60 
Con colores, estilos y demás.. 


----------------------- Configuración inicial necesaria (por defecto con startproject)
<IMAGEN> img61

Cuando comenzamos con el proyecto se instala el django admin.

- Si vemos el django encontramos el contrib - > Admin




----------------------- Configuración inicial necesaria (por defecto con startproject)
<IMAGEN> img62

Los middlewares es código que se ejecuta ANTES de que llegue a nuestro sitio..
Entre que ingresa al server y llega a nuestro backend.

                            -> admin, podemos poner el nombre que deseemos
Debemos agregar o linkear la url de admin/, admin.site.urls..

----------------------- Configuración inicial
<IMAGEN> img63

* Por lo cual podremos tener dos administraciones.. El propio de la página y el admindjango.

Desde consola:
    - python manage.py createsuperuser          -> Definimos el nombre del usaurio.
    
    Este usuario lo usamos dentro del django_admin..
        is_stafs   -> El que tiene más privilegios, si es True, entra

* Para el lenguaje, recordar el LANGUAGE_CODE = 'es-ar' -> Castellano argentino


---- Ejemplo Práctico

from django.contrib import admin
from cac.models import Estudiante, Comision             -> Registramos nuestros modelos con la interfaz del Django Admin


class EstudianteAdmin(admin.ModelAdmin):
    pass


admin.site.register(Estudiante, EstudianteAdmin)        -> Acá además agregamos la comision
# admin.site.register(Comision)                         -> Con esta linea agregamos al Admin el Modelo de Estudiante

@admin.register(Comision)
class ComisionAdmin(admin.ModelAdmin):
    pass


--- Además dentro de los models.py sobreescribimos el __str__ para visualizar la data de manera más clara..

class Estudiante(models.Model):
    nombre = models.CharField(max_length=100, verbose_name='Nombre:')
    apellido = models.CharField(max_length=150, verbose_name='Apellido:')
    email = models.EmailField(
        max_length=150, verbose_name='Email:', null=True, default=None)
    dni = models.BigIntegerField(verbose_name='DNI:')
    comision = models.ForeignKey(Comision, on_delete=models.SET_NULL, null=True)

    class Meta:
        verbose_name_plural = "Estudiantes"

    def __str__(self):
        return f"DNI: {self.dni} - {self.apellido}, {self.nombre}"          -> De está manera visualizamos la data en Django Admin







----------------------- Configuración inicial
<IMAGEN> img64

----------------------- Y los modelos?
<IMAGEN> img65

----------------------- Registro modelos
<IMAGEN> img66

----------------------- Registro modelos


----------------------- Registro modelos

----------------------- Registro modelos

-----------------------

Además si en el models.py... Agregamos la Comisión y el Estudiante

from ast import mod
from email.policy import default
from tabnanny import verbose
from django.db import models


class Comision(models.Model):                                                           -> Comision
    nombre = models.CharField(max_length=150, verbose_name='Comsion:')                  *  Cada charField va pensado con detenimiento de antemano.
    imagen = models.ImageField(verbose_name="Imagen:", default=None, null=True)                 -> Esto es para la imagen.

    class Meta:
        verbose_name_plural = "Comisiones"                      -> Podemos decirle al modelo como se  nombrará en plural.
                                                                *  Para ordenarlos a criterio podemos usar  verbose_name_plural = " 01 - Comisiones"        -> Forma simple para reorganizar.
    def __str__(self):                                                            Y en la otra clase usar   verbose_name_plural = " 02 - Estudiantes"       *  O dejarlo sin el num, para legibilidad.
        return self.nombre

    def delete(self):
        self.imagen.delete()                                    -> ESTO ES PARA ELIMINAR LA IMAGEN
        return super().delete()                                 *  Borramos la imagen ANTES de eliminar la comisión/la entidad


class Estudiante(models.Model):                                                         -> Estudiante
    nombre = models.CharField(max_length=100, verbose_name='Nombre:')
    apellido = models.CharField(max_length=150, verbose_name='Apellido:')
    email = models.EmailField(
        max_length=150, verbose_name='Email:', null=True, default=None)
    dni = models.BigIntegerField(verbose_name='DNI:')
    comision = models.ForeignKey(Comision, on_delete=models.SET_NULL, null=True)            * La comisión está asociada a la comision
                                                                                            * on_delete=models.SET_NULL no en cacade, dejaremos nulos de ser necesario.
    class Meta:
        verbose_name_plural = "Estudiantes"

    def __str__(self):
        return f"DNI: {self.dni} - {self.apellido}, {self.nombre}"

    def save(self, *args, **kwargs):
        if self.apellido.upper() == 'MESSI':
            raise ValueError("Messi es un maestro, no puede ser estudiante")
        else:
            super().save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        if self.apellido.upper() == 'ALMADA':
            raise ValueError("No se puede eliminar, tiene mucho que aprender")
        return super().delete(*args, **kwargs)


--- Ahora en el Admin.py

from django.contrib import admin
from cac.models import Estudiante, Comision


class EstudianteAdmin(admin.ModelAdmin):
    pass


admin.site.register(Estudiante, EstudianteAdmin)            -> EstudianteAdmin, manejamos un admin específico para ese Admin
# admin.site.register(Comision)

@admin.register(Comision)
class ComisionAdmin(admin.ModelAdmin):
    pass



Por lo tanto el Django Admin será más para el usuario de Sistema..
El otro admin más para el usaurio final.




* Para sibur una imagen...
desde settings.py

MEDIA_URL = 'media/'
MEDIA_ROOT = BASE_DIR / 'media'                 -> La carpeta media, la debemos crear...
                                                * Para borrar la imagen del lugar fisico, le especificamos el método delete.

-----------------------

-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 17. Personalizando el Django Admin y relaciones muchos a muchos con tabular inline (Clase 27)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Admin - 2
    ● Modelos muchos a muchos
    ● Personalizando DjangoAdmin

 
----------------------- Modelos muchos a muchos
<IMAGEN> img67

    ManyToManyField -> Donde lo decidimos poner.. Genera una tabla intermedia.


*Un estudiante puede pertenecer a muchas comisiones..
Una comision puede tener muchos estudiantes

----------------------- Modelos muchos a muchos
<IMAGEN> img68

    __str__ para mostrar el modelo en concreto..
            * La representación en String.


----------------------- Modelos muchos a muchos
<IMAGEN> img69

--- Ejemplo práctico.

    django.contrib.admin        -> Instalada.



* Para sobreescrir el Django Admin..


class EstudianteAdmin(admin.ModelAdmin):
    list_display = ('legajo', 'apellido', 'nombre')         -> Manera de visualizar el modelo en el Djangoadmin
    # list_editable = ('apellido', 'nombre')                -  Para tener campos editables o no
    list_display_links = ('legajo',)                        -  Botones cickleabes
    search_fields = ['apellido']                            -  Para buscar dentro de apellido



class DocenteAdmin(admin.ModelAdmin):               
    list_display = ('cuit', )
    form = DocenteForm                                      -> Para ver un form, para agregar el Docente


--- Otra manera, con los decoradores


@admin.display(description='Nombre del curso en mayuscula')
def curso_mayuscula(objeto):
    return f"El Curso {objeto.nombre}".upper()                  -> De esta manera especificamos la data en mayúscula
                                                                *  Son como "etiquetas" que no afectarán el modelo.

@admin.register(Curso)                          -> modelo que se registra para el curso
class CursoAdmin(admin.ModelAdmin):
    # formfield_overrides = {
    #     models.TextField: {'widget': widgets.CacTextWidget}
    # }
    list_display = (curso_mayuscula, 'curso_minuscula', )               -> De esta manera podemos modificar la manera de mostrar los elementos

    @admin.display(description='Nombre del curso en minuscula')
    def curso_minuscula(self, objeto):                                  -> En minúscula, le agregamos además el nombre de las columnas
        return f"Curso {objeto.nombre}".lower()



--- Un model @admin, asociado a un modelo se registra una única vez..

@admin.register(Comision)
class ComisionAdmin(admin.ModelAdmin):
    list_display = ('nombre', 'fecha_inicio', )                                 -> Columnas a mostrar
   
    def formfield_for_manytomany(self, db_field, request, **kwargs):            -> Sobreescribimos el método de obtener el mucho a muchos.
        if db_field.name == "estudiantes":
            kwargs["queryset"] = Estudiante.objects.filter(legajo__startswith="2").order_by("apellido")
        return super().formfield_for_manytomany(db_field, request, **kwargs)



--- Para configurar nuestro pgAdmin

INSTALLED_APPS = [
    #  'django.contrib.admin',  # Utiliza el autodiscover para obtener el admin de todas las aplicaciones en "INSTALLED_APPS"
    'django.contrib.admin.apps.SimpleAdminConfig',  # No utiliza el autodiscover se debe hacer todo a mano"
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django_extensions',
    'cac'
]


Ahora desde el admin.py...


class CacAdminSite(admin.AdminSite):                        -> Modificamos el formato del django admin, como se mostrarán los titulos y demas.
    site_header = "Administración de Codo a Codo"
    site_title = "Administración para super usuarios"
    index_title = "Administrador del Sitio"
    empty_value_display = "No hay nada"



Instanciamos el objeto de arriba.. Y le registramos los modelos..


sitio_admin = CacAdminSite(name='cacadmin')             -> Instanciamos
sitio_admin.register(Docente)
sitio_admin.register(Curso)                             - Registramos los modelos
sitio_admin.register(Estudiante, EstudianteAdmin)
sitio_admin.register(Comision, ComisionAdmin)


--- Ahora desde las urls.py debemos importar el sitio_admin

from django.contrib import admin
from django.urls import path
from django.urls.conf import include
from cac.admin import sitio_admin                   -> Importamos


urlpatterns = [
    path('cac_admin/', sitio_admin.urls),           -> Lo agregamos
                                                    * Podriamos agregar diferentes rutas para mostrar o obviar diferente información.
    # path('super_admin/', admin.site.urls),
    path('', include('cac.urls'))
]

--- Sobreescribir el Html del django Admin..
Agregamos el templates en la raíz del proyecto.. Agregamos la carpeta admin, y un base.html


{% extends 'admin/base.html' %}

{% block extrastyle %}{{ block.super }}
<style>
:root {
  --primary: #9774d5;
  --secondary: #785cab;
  --link-fg: #7c449b;                   -> Agregamos estilos de Css al Django Admin.
  --link-selected-fg: #8f5bb2;
}
</style>
{% endblock %}


--- 
# nuestro propio sitio admin
from django.contrib import admin
from cac.models import Estudiante, Docente, Curso, Comision, Inscripcion

class CacAdminSite(admin.AdminSite):
    site_header = "Administración de Codo a Codo"
    site_title = "Administración para super usuarios"
    index_title = "Administrador del Sitio"
    empty_value_display = "No hay nada"

# Versión 1: si definimos un modelo intermedio
class InscripcionInline(admin.TabularInline):
    model = Inscripcion
    extra = 1

# # Versión 2:si no tenemos un modelo intermedio (cambia la asociación del inline en admins)
# class InscripcionInline(admin.TabularInline):                     - La tabla intermedia, hereda de TabularInline
#     model = Comision.estudiantes.through
#     extra = 1  # cuantas opciones de carga aparecen por defecto


class EstudianteAdmin(admin.ModelAdmin):
    list_display = ('legajo', 'apellido', 'nombre')
    list_display_links = ('nombre', 'apellido', )
    fields = (('nombre', 'apellido'), 'legajo')  # Si no hacemos un valor editable debe manejarse dicha situación de alguna manera.
    # ambas versiones
    inlines = (InscripcionInline, )             -> Hereda de InscripcionInline


class ComisionAdmin(admin.ModelAdmin):
    # ambas versiones
    inlines = (InscripcionInline, )
    # version 2 evitamos doble carga
    exclude = ('estudiantes', )                 -> Excluimos 


* Con el TabularInline -> Nos queda de manera dinámica todo enganchado y utilizable.


--- Ahora en el models.py

class Comision(models.Model):
    class Meta:
        verbose_name_plural = _("Comisiones")

    nombre = models.CharField(max_length=100, verbose_name='Nombre')
    descripcion = models.TextField(null=True, verbose_name='Descripcion')
    fecha_inicio = models.DateField(verbose_name='Fecha de inicio')
    portada = models.ImageField(upload_to='imagenes/comisiones/', null=True, verbose_name='Portada', default=None)
    curso = models.ForeignKey(Curso, on_delete=models.CASCADE)
    docente = models.ForeignKey(Docente, on_delete=models.SET_NULL, null=True)
    # version 1 admin
    estudiantes = models.ManyToManyField(Estudiante, through='Inscripcion')                     -> Si con la tabla intermedia DEFINIDA, Inscripcion, con esa tabla hacemos la relación
    # version 2 admin
    # estudiantes = models.ManyToManyField(Estudiante)

    def __str__(self):
        return self.nombre

    def delete(self, using=None, keep_parents=False):
        self.portada.storage.delete(self.portada.name)  # borrado fisico de la imagen
        super().delete()


class Inscripcion(models.Model):                                                                -> Esta tabla hará la relación
    class Meta:
        verbose_name_plural = _("Inscripciones")

    class Estado(models.IntegerChoices):
        INSCRIPTO = 1
        CURSANDO = 2
        EGRESADO = 3

    fecha_creacion = models.DateField(verbose_name='Fecha de creación')
    estudiante = models.ForeignKey(Estudiante, on_delete=models.CASCADE)
    comision = models.ForeignKey(Comision, on_delete=models.CASCADE)
    estado = models.IntegerField(choices=Estado.choices, default=Estado.INSCRIPTO)
    # opción sin crear la clase interna Estado
    # estado = models. IntegerChoices("Estado", 'INSCRIPTO CURSANDO EGRESADO')

    def __str__(self):
        return self.id



# Versión 1: si definimos un modelo intermedio
class InscripcionInline(admin.TabularInline):
    model = Inscripcion                                                 -> Ahora si tenemos la tabla intermedia
    extra = 1

# # Versión 2:si no tenemos un modelo intermedio (cambia la asociación del inline en admins)
# class InscripcionInline(admin.TabularInline):
#     model = Comision.estudiantes.through
#     extra = 1  # cuantas opciones de carga aparecen por defecto


* De esta manera tendremos un TabularInline, con una tabla definida.


----------------------- Modelos muchos a muchos
<IMAGEN> img70

----------------------- Personalizando el sitio por defecto del DjangoAdmin
<IMAGEN> img71

----------------------- Personalizando el sitio por defecto del DjangoAdmin
<IMAGEN> img72


----------------------- Personalizando nuestro DjangoAdmin
<IMAGEN> img73

----------------------- Personalizando nuestro DjangoAdmin
<IMAGEN> img74

-----------------------
-----------------------
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 18. Django Authentication  Autenticación y autorización desde Django (Clase 28)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Autenticación - 1
● Autenticación vs Autorización
● Instalación
● Usuarios y Grupos
● Is_authenticated
● Decorator login_required
● Limitar acceso en templates


----------------------- Autenticación y Autorización
<IMAGEN> img75

Autenticación   -> Quien soy your
    Se, tengo, soy  factores básicos.

Autorización    -> Que puedo hacer

----------------------- ¿Qué es Django Authentication?
<IMAGEN> img76

Autentica y autoriza, django auth.

----------------------- Configuración
<IMAGEN> img77


----------------------- Objeto User
<IMAGEN> img78

Con sus respectivos atributos


----------------------- Objeto User
<IMAGEN> img79

Usamos el manager    -> .objects

is_staff   -> si está en un True, entrá al Django Admin

----------------------- Contraseñas
<IMAGEN> img80

Las constraseñas cuando se ingresan, se hashean..

El hash que se encuentra en la base de datos.. Es comparado con el hash creado al momento de iniciar sesión.
Si son iguales, está okey.. Todo esto es configurable



----------------------- Autenticando usuarios
<IMAGEN> img81

Autenticar no quiere decir loguearse.. Autenticar es Validar si es correcto el usuario y contraseña.
Loguearse es guardar el usuario y la contraseña en la sesión, 


----------------------- Permisos y Autorización
<IMAGEN> img82

Esto es importante, dedicarle el tiempo para saber quien hace que y con que alcance.

----------------------- Permisos y Autorización
<IMAGEN> img83

----------------------- Permisos y Autorización
<IMAGEN> img84

----------------------- Permisos y Autorización
<IMAGEN> img85
-----------------------
<IMAGEN> img86

El form para agregar usuario, se puede usar también en el Front.

----------------------- Iniciar y cerrar sesión en un usuario

<IMAGEN> img87

Acá vemos la diferencia entre autenticar y loguear.. Con el login, le pasamos el request y el user.

Con el logout(request)  deslogueamos al usuario.

----------------------- Limitar acceso a usuarios registrados en vistas

<IMAGEN> img88
----------------------- Limitar acceso a usuarios registrados en vistas basadas en clases


<IMAGEN> img89
----------------------- Limitar acceso a vistas basadas según permisos

<IMAGEN> img90
----------------------- Limitar acceso a usuarios registrados en templates

También podemos hacerlo desde el template y desde la vista..


<IMAGEN> img91
----------------------- Limitar acceso a permisos en templates

<IMAGEN> img92

----------------------- Ejemplo práctico

En el settings.py..

INSTALLED_APPS = [
    #'django.contrib.admin',  # Utiliza el autodiscover para obtener el admin de todas las aplicaciones en "INSTALLED_APPS"
    'django.contrib.admin.apps.SimpleAdminConfig',  # No utiliza el autodiscover se debe hacer todo a mano"
    'django.contrib.auth',                          -> Corroboramos el auth
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django_extensions',
    'cac'                                           -> Nuestra app
]

--- En el html, index.. Mostramos o no los usuarios.

    {% if user.Is_authenticated %}          -> De esta manera debajo mostramos toda la data necesaria.  


--- Ahora desde la views.py
from django.contrib.auth import authenticate, login, logout


def cac_login(request):
    if request.method == 'POST':
        # AuthenticationForm_can_also_be_used__
        username = request.POST['username']
        password = request.POST['password']
        user = authenticate(request, username=username, password=password)              -> Con el authenticate
        if user is not None:
            form = login(request, user)
            messages.success(request, f' Bienvenido/a {username} !!')
            return redirect('inicio')
        else:
            messages.error(request, f'Cuenta o password incorrecto, realice el login correctamente')
    
    form = AuthenticationForm()
    return render(request, 'cac/publica/login.html', {'form': form, 'title': 'Log in'})


--- Ahora desde la urls.py configuramos el logout.. 

    path('cuentas/logout/',
         auth_views.LogoutView.as_view(template_name='cac/publica/index.html'), name='logout'),

--- Ahora desde la urls.py configuramos el login y register.. Basado en vista en clase.
 
    path('', views.index, name='inicio'),
    # path('accounts/', include('django.contrib.auth.urls')),
    path('cuentas/registrarse', views.cac_registrarse, name='registrarse'),
    path('cuentas/login', views.cac_login, name='login'),
 

-----------------------
-----------------------

-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 19. 
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------

Django: Authentication - 2
    ● Configurando vistas y  templates de django.contrib.auth por defecto
    ● Login de usuarios
    ● Logout de usuarios
    ● Modificación de usuarios

----------------------- Configurar urls de autenticación por defecto
Usaremos vistas basadas en clase.. Es más sencillo para sobreescribir algo.


<IMAGEN> img93

Si registramos la url accounts/ nos provee todo de manera automática, menos el register..

    accounts/login      -> De esta manera manejamos de manera automática y están relacionadas
    accounts/logout


----------------------- Urls y nombres generados por defecto

<IMAGEN> img94

Estas son generedas de manera automáticas.. VBC -> Vistas basadas en clases.

* De esta manera, también podemos configurar el reseto de password..

Con tan poco se puede crear mucho.

----------------------- Vistas de autenticación
<IMAGEN> img95

La de Login -> la loginView, tiene atributos y responsabilidades.

redirect_field_name -> Redireccion de la pagina

template_name -> indica en que lugar estará el login.html


--- Ejemplo práctico

En el urls.py... Vemos las urls de las accounts..

urlpatterns = [
    # accounts/login/ [name='login']
    # accounts/logout/ [name='logout']
    # accounts/password_change/ [name='password_change']                            -> Podemos elegir cual agregar y cual no
    # accounts/password_change/done/ [name='password_change_done']
    # accounts/password_reset/ [name='password_reset']
    # accounts/password_reset/done/ [name='password_reset_done']
    # accounts/reset/<uidb64>/<token>/ [name='password_reset_confirm']
    # accounts/reset/done/ [name='password_reset_complete']
    path('accounts/password_change/', auth_views.PasswordChangeView.as_view(success_url="/"), name='password_change'), 
    path('accounts/registrarse', views.cac_registrarse, name='registrarse'),
    # path('accounts/login', auth_views.LoginView.as_view(template_name="cac/publica/login.html"), name='login'), 
    path('accounts/', include('django.contrib.auth.urls')),
    # path('cuentas/login', views.cac_login, name='login'),
 

--- Le indicamos en el settings.py


# REGISTRATION
LOGIN_REDIRECT_URL = "inicio"           -> Donde redirigimos después del login y el logout
LOGOUT_REDIRECT_URL = "inicio"          -> Le indicamos el nombre del path de la url
                                        Que es esta:
                                                path('', views.index, name='inicio')



--- Debemos agregar la carpeta dentro del templates llamado "registration" y el login.html
Si no existe, lo generamos.. Si existe lo sobrescribimos

El template se hará de acuerdo a lo sugerido por Django

    path('accounts/', include('django.contrib.auth.urls')),         -> Al incluir los templates por defecto, irá a buscar esa plantilla en específico

Al poner el login.html  que es el archivo base.


----------------------- Vistas de autenticación
<IMAGEN> img96

--- O bien podemos una especificamente, no de manera general como la anterior.

    # path('accounts/login', auth_views.LoginView.as_view(template_name="cac/publica/login.html"), name='login'), 

----------------------- Vistas de autenticación
<IMAGEN> img97

Luego vemos el logout.. Va a una vista, saca de sesión al usuario.


* Podemos usar el cambio de contraseña por defecto, usando la plantilla por defecto Django..
Con pocas líneas tenemos toda la autenticación por defecto.

----------------------- Extendiendo el Usuario
<IMAGEN> img98

2 maneras, generalmente se extiende el modelo existente..

El perfil de visualización, datos extras, es uno a uno con el usuario.. EL usuario maneja la autenticación.


Para abstraer el User, podemos agregarle nuevas propiedades o funcionalidades..
Usando el nuevo modelo.

-----------------------
De esta manera exigimos el login..

# @login_required
# def mi_vista(request):
#     ...


O bien extendemos del login en la vista base en clases..

# from django.contrib.auth.mixins import LoginRequiredMixin

# class MiVista(LoginRequiredMixin, View):
#     login_url = '/login/'
#     redirect_field_name = 'redirect_to'
#    


-----------------------
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 20. Django: Rest Framework (Clase 31)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Rest Framework
    ● WebSite vs WebApi
    ● Serializadores
    ● Instalación y configuración django rest framework
    ● Authenticación
    ● Routers
    ● Vista

Para generar una Api dentro del sitio..
No orientado a microservicios.

Nuestra Api le brinda información a otro sistema.
Con una aplicación de Django, podemos proveer un servicio.

----------------------- Recordemos
<IMAGEN> img99

* 

----------------------- REST API Model
<IMAGEN> img100

Con este tipo de modelo.. Tenemos un PUNTO DE ENTRADA.. El cual se comunicará con el servidor.
Es el endpoint, la api está dentro del server.

No es una arquitectura, es una manera de modelar una Api.
También están las SOAP, son "Metodologías"..


¿Para que se piensa?
Es un punto donde se recibe un solocitud un request, y emitimos una respuesta, un response.
Lo que recibe el cliente:
    - json  -> Más independiente de la tecnlogía.
    - xml
    - html

Es una manera de pensar una arquitectura, empleando Rest Api, para permitir servicios, antes eran Soap.


----------------------- Modelos combinados
<IMAGEN> img101

La página está creada en HTML y..
La api la proveemos para un sitio externo, que puede ser un celular, un banco, etc.. 
    - De esta manera permitimos a través del framework para comunicar con otros servicios.
    - Podría existir o no.


En la página, proveemos un endpoint para mostrar a los estudiantes.
    - Por medio de la api se puede hacer un post, un get, etc.. Dependerá de la lógica de negocio.


----------------------- Instalación
<IMAGEN> img102

    djangorestframework -> Con el pip en el entorno..

    La debemos agregar en las app instaladas.

    Y debemos agregar las urls que deseemos manejar..
        - Por defecto, crea una api para autenticar.. Responde con el user.
        - Además crea la parte visual.

    * Autenticación con Token es lo más utilizado.. Lo anterior no tanto.



----------------------- Serialización
<IMAGEN> img103

Transformar un objeto, en un string (Texto), algo serializable..
Que puede ser transportado a través de HTTP..

Serializar: Agarramos el objeto lo pasamos a un string
Desserializamos: Agarramos el String y lo pasamos a un objeto.

¿Que objeto? Dependerá de la tecnlogía..

Server, objetos de python, de django, modelos.. Todo esto lo transforma y lo envía al cliente.




----------------------- Ejemplo práctico
<IMAGEN> img104



--- Ejemplo

No usaremos microservicios..
De esta manera no individualizamos sino más bien acoplamos la Api al website.


Generamos la app de django..
    - django-admin startapp cac_api

        - serializer    ->
        - urls.py       -> Punto de entrada a nuestra Api.
        - views.py      -> Funciones que reciben la llamada de la URL.



----------------------- Serializers.py
<IMAGEN> img105

    - Que hace? Transforma el objeto a un string o al revés.
Ya viene todo armado.. De esta manera asociamos el modelo con el ModelSerializer

En este ejemplo vemos asociado el modelo con la api.. O sea, ese acoplamiento y no usando la estructura de microservicios.

--- 


----------------------- Views.py (ViewSets)
<IMAGEN> img106

Usamos las vistas que provee el framwork.. Vistas basadas en calse, VBC

    EstudianteMViewSer -> Nombre elegido arbitrariamente con relación al modelo.

    El queryset lo manejamos a través del manager.. objects.

    nos traemos el serializer.EstudianteMSerializer

    permission_classes ->   Si la vista tiene o no seguridad..
                            En el ejemplo exigimos la autenticación y que sea read only


* De esta manera generamos las vistas para obtener lo que sea necesario de acuerdo a los estudiantes..
Obtenerlos todos, algunos, uno solo y etc..


----------------------- Urls.py (Routers)
Ahora con las vistas creadas.. Registradas a través de la vista basada en Clase ModelViewSet..
Procedemos armar las urls..

<IMAGEN> img107 

con el router.. Genera todo de manera automática..
    - Es decir vistas asociadas a urls.. de listar, grabar uno, actualizar uno, etc.
    


--- Ejemplo Práctico
Generamos nuestra app_api..


--- serializers.py
from rest_framework import serializers
from cac.models import EstudianteM          -> Importamos desde el modelo del cac


class EstudianteMSerializer(serializers.ModelSerializer):                                   -> Hereda del framework
    class Meta:
        model = EstudianteM                                                                 -> Asociado al EstudianteM
        fields = ['id', 'nombre_m', 'apellido_m', 'email_m', 'dni_m', 'matricula_m']        * El modelo es que tenemos en nuestro proyecto general.
                                                                                            * 
    


--- urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from cac_api import views

router = DefaultRouter()
router.register(r'estudiantes', views.EstudianteMViewSet, basename='estudiante')            -> De manera automática nos traemos todas

urlpatterns = [                                                                             * O bien, especificando las url de manera manual..
    path('', include(router.urls)),                                                         -> Agregamos las urls de manera automática
    path('api-auth', include('rest_framework.urls', namespace='rest_framework'))            -> Genera la capa de autenticación automática
]



--- views.py
from rest_framework import viewsets
from rest_framework import permissions
from cac.models import EstudianteM
from cac_api import serializers


# Create your views here.
class EstudianteMViewSet(viewsets.ModelViewSet):
    queryset = EstudianteM.objects.all().order_by('id')                 -> Acá podemos hacer los filtros y los cambios necesarios en la info que traemos.
    serializer_class = serializers.EstudianteMSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

--- Ahora en el pig_22820/urls.py

from django.contrib import admin
from django.urls import path
from django.urls.conf import include
from cac.admin import mi_admin
from cac_api import urls as api_urls                    -> Lo nombramos como api_urls

urlpatterns = [
    path('cac_api/', include(api_urls)),                -> Linkeamos la api
    path('cacadmin/', mi_admin.urls),
    path('admin/', admin.site.urls),
    path('', include('cac.urls'))
]





----------------------- Ejemplo práctico (interfaz automática)
<IMAGEN> img108

    localhost:8000/cac_api/            -> Nos genera el endpoin de nuestra base de datos.

    - Ahora si apuntamos con el postman a esa url.. Aplicamos los verbos HTTPS


    Para hacer un post, es necesario hacer la autenticación.. De lo contrario solo usamos el get.


    localhost:8000/cac_api/         -> Si vamos al login, 
        - Ponemos el usuario y la contraseña.. Iniciamos y podemos entrar con el Post.
        - Si fuese necesario.. Podemos hacer el put a través del id de los elementos.. También el Delete.

    * De esta manera nos provee toda una interfaz gráfica..

-----------------------

Si quisieramos hacerlo desde el frontend.. Podemos hacer un fetch usando js..
-- Por ejemplo
const divProyectos = document.querySelector("#divProyectos");

fetch('/api_proyectos')                                         -> Le armamos 
  .then((response) => response.json())
  .then((data) => {
    console.log(data);
    let proyectos = data.data;
    proyectos.forEach(proyecto => {
        let html = renderProyecto(proyecto);
        divProyectos.insertAdjacentHTML('beforeend', html);
    });
  });

-----------------------
Usar un plugins o el framework view para que desde la vista.. Podemos consumir la api.
O bien el propio Django..
    
    import requests

    respuesta = requests.get("https://api")         -> La requests la podemos manejar a gusto.. Que mostrar y demás.
                                                    * Esto se hace en la views.py, el tiempo de respuesta puede variar y el servidor se puede caer.
                                                    * AWS es gratis, pero c


De esta manera con un serializer para mostrar la información de acuerdo a lo necesario.

También hay que considerar el asincronismo al momento de manejar las Apis.. Hacer el await y demás.

-----------------------



-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 21. Django: Despliegue de servidor (Clase 32)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Despliegue en servidor
    ● Tipos de infraestructuras (IaaS, PaaS, SaaS)
    ● Load Balancer
    ● Python Anywhere
    ● Heroku
    ● Amazon EC2
    ● Docker

----------------------- 
Python Anywhere -> Debemos crear usuario y demás.

render.com


----------------------- Infreastructuras
<IMAGEN> img109

- ¿Donde guardar los archivos?
- ¿Hacer o no backup de los archivos?
- ¿Tener un servicio de git?
- ¿Si va estar todo en el mismo servidor? ¿O aparte? ¿Como se van a conectar?
- ¿Si tendremos servidores comunicados como respaldo o queda offline nuestra página?

- Infrasestructura = Dinero


SAAS -> Software como servicios. Utilizamos el Software. Menos control

PAAS -> Plataforma como servicios. Como Heroku.

IAAS -> Infrasestructura como servicios. Aws, azure, google compute engine. Armamos la estructura.
        * Es mayor el control que podemos usar, tenemos que armar una maquina virtual, colocarle un sistema operativo, conectarlo con la base de datos.
        * Pensar la seguridad y demás, o sea, muchos más conocimientos.


----------------------- PAAS
Heroku          


PythonAnywhere  -> Tiene una capa gratuita.
                *  Dejo de proveer postgresssql de manera gratuita, solo mysql.

----------------------- Elastik VeanStalk - EC2(Server), RDS(DB), Files(S3)
<IMAGEN> img110

    - Para armar un servidor de Django.


    EC2 ->  Maquina virtual, para django es mejor linux.
            * Tener replicas.
            - Arriba una capa, el Load Balancer una maquina, que va equilibrando los request.. Balanceando las Cargas.
                                - De esta manera tendremos un response más rápido.

    S3  ->  Servicio de guardado de archivos estáticos.
            Storage Service, se guarda en otro server

    RDS ->  Relation Database, donde guardamos la base de datos.
            Hay capas gratuitas en cada servicio..   FREE TRIAL
            Estan pre definidas.. 


----------------------- ¿Que es DOcker?

Es un software, que maneja contenedores.
Es una maquina virtual ejecutable dentro de otro sistema operativo.

Plataformas -> Kubernetes.

Hace lo que tendríamos hacer en un sistema operativo.
    - Asignar memoria.
    - Configurar puertos.           ->  Son sentencias que luego corren en otros sistemas.
    - Conectar a la base de datos       

Docker es el intermediario..    Y con las sentencias es el plan de acción, para ejecutar todo.
                                Maquina virtual ejecutable adentro de cualquier sistema operativo que posea docker


----------------------- 
Pythonanywhere + Github

Más sencillo para hacer el despliegue de manera automática.
Creamos el Api Token.. Deja activo la instancia para luego utilizarla.

Databases, creamos la instancia de base de datos.

----------------------- 
----------------------- 
 