||||| FullStack Python


1| 10. Base de Datos - 1 (Clase 18)
1| 11. Base de Datos - 2 (Clase 19)
1| 12. Models - 1 (Clase 21)
1| 13. Models - 2 (Clase 22)
1| 14. Models - 3 (Clase 23)
1| 15. Models - 4 (Clase 24)
1| 16. Django: Admin - 1 (Clase 26)
1| 17. Personalizando el Django Admin y relaciones muchos a muchos con tabular inline (Clase 27)
1| 18. Django Authentication  Autenticación y autorización desde Django (Clase 28)
1| 19. Django: Rest Framework (Clase 31)
1| 20. Django: Despliegue (Clase 32)


-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 12. Models - 1 (Clase 21)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
 
Django: Models - 1
    ● Crear modelos
    ● Campos y atributos (DjangoFields)
    ● Migraciones de modelos (makemigrations, migrate)
    ● Django Shell


----------------------- ¿Qué es un Modelo?
Un modelo es la fuente única y definitiva de información sobre los 
datos en Django. Contiene los campos y comportamientos esenciales 
de los datos que se están almacenando. Generalmente, cada modelo se 
asigna a una tabla de base de datos.

Las migraciones son necesarias para replicarla luego en otro lugar la misma base de datos.

----------------------- Recordemos

El Orm trabaja en el circulo azul, en el modelo en conexión con la base de datos.
El django.models se encarga de todo y devuelve un queryset.

*Todo se puede sobreescribir en Django, algunas cosas más sencillas otras mas complejas.

 
----------------------- Creación de un Modelo

<IMAGEN> img32

La aplicación, la debemos instalar (INSTALLED_APPS)...
Y generamos nuestro archivo models.py



----------------------- Creación de un Modelo

<IMAGEN> img33
Heredamos de la clase models.. Y esto queda persistido.


Si cambiamos de postgresql a mysql.. Los campos, CharField serán los mismos.

----------------------- Creación de un Modelo

----------------------- Migración

<IMAGEN> img34
hacer makemigrations    -> Actualizamos los cambios
hacer migrate           -> Persistimos

----------------------- Creación de un Modelo

<IMAGEN> img35
Si no especificamos el id, dentro de la clase Estudiante, django lo crea automáticamente..
    -

* No utilizar identificadores únicos que correspondan al negocio.. Porque, porque el negocio cambia.


----------------------- Creación de un Modelo

Con la migración generamos el siguiente script.. 

<IMAGEN> img36



  
----------------------- postgresql_psycopg2

Podemos ver en el conector psycopg2.. Que representa con PostgreSQL..

<IMAGEN> img37




----------------------- Ejemplo Práctico

Creamos la base de datos en el PgAdmin.. Con el nombre deseado.

En el
DATABASES = {
        -> Configuramos Todo
}

Ahora en el models.py.. Dentro de nuestra app, cofiguramos lo necesario de acuerdo a los campos.
    Todo lo que se puede hacer en la base de datos, lo armamos desde el models..



- Desde el ambiente virtual.

    - python manage.py makemigrations               -> De esta manera vemos las diferencias.
                                                    -  "Saca" la foto para anter de llevar todo a la BD

    - python manage.py migrate                      -> De esta persistimos todo contra la base de datos..
                                                    -  Aplica y persiste todo contra la BD

* Las migraciones se suben a Git.


----------------------- Django Shell (spoiler QuerySet)

Para guardar data desde consola usando la Django Shell..

    - python manage.py shell


Abrimos la consola..

    - estudiante = Estudiante(nombre="Maat", apellido="Reef", email="maat_reef@gmail.com", dni=2234)
    - estudiante.save() 

            -> Guardamos la data en la base de datos, a través del ORM
            * De esta manera hacemos el INSERT

    * pip install django_extensions         -> Instalamos el plugin..


    'django_extensions'  -> Debemos guardarlo dentro de las Apps.


    - python .\manage.py shell_plus         -> Tenemos una linea de comandos más amigable
                                            -  Shell plus, 


    - estudiante = Estudiante(nombre="Hermes", apellido="Prato", email="123@gmail.com", dni=24)
    - estudiante.save() 


* Con todo esto, abre y cierra conexiones.. 


<IMAGEN> img38

    - De esta manera tenemos los métodos para traer y mostrar la data..

    - Estudiante.objects.all()


* Consejo considerar cuando hacer las migraciones, hacerlo de manera definida.
- Hacer una inicial y mantenerlo simple..

Si tenemos muchas migraciones..
- Creamos la base de datos y hacemos las migraciones necesarias..

----------------------- 

-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 13. Models - 2 (Clase 22)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Models - 2
    ● Relaciones entre modelos
    ● Herencia de modelos
    ● QuerySets (lazyloading)



----------------------- Recordemos

<IMAGEN> img35

----------------------- ¿Qué tipo de relaciones hay?

Django ofrece formas de definir los tres tipos más comunes de 
relaciones de base de datos: muchos a uno, muchos a muchos y uno a 
uno. En lo que respecta a las relaciones de uno a uno, no solo 
podremos definirlas como una relación, sino también utilizando la 
técnica de herencia

El Orm transforma las clases a tablas en la abase de datos.

----------------------- Relaciones de muchos a uno
<IMAGEN> img36
Una categoría puede tener muchos cursos
Por ende la clave foránea va en Curso.. El curso está relacionado con una Categoría.

on_delete.. Cuando se borra la categoría.. Con..
    models.CASCADE  -> Cuando se borra la categoría arrasta borrando todo los asociados de la base de Datos, usando DJango.
    models.SET_NULL -> No la borra, solo deja en nula categoría.



 
# class Curso(models.Model):
#     nombre = models.CharField(max_length=100, verbose_name='Nombre')
#     # descripcion = models.TextField(null=True, verbose_name='Descripcion')                       * Los campos escritos de manera en singular.
#     # fecha_inicio = models.DateField(verbose_name='Fecha de inicio')
#     # portada = models.ImageField(upload_to='imagenes/', null=True, verbose_name='Portada')
#     # categoria = models.ForeignKey(Categoria, on_delete=models.CASCADE)                          -> CASCADE
#     # estudiantes = models.ManyToManyField(Estudiante)

#     def __str__(self):
#         return self.nombre


# class Estudiante(models.Model):
#     nombre = models.CharField(max_length=100, verbose_name='Nombre')
#     # apellido = models.CharField(max_length=150, verbose_name='Apellido')
#     cursos = models.ManyToManyField(Curso)

#     def __str__(self):
#         return self.nombre


--------------------------------- Extra
* Que es el borrado logico?
    - No es eliminado de la base de datos.. Pero le dejamos un flag, por ejemplo si ese elemnto necesita ser auditadto
    * De esta manera cuando nos traemos los elementos, lo nos traremos los restore, ya que tienen el self.baja en False

    def soft_delete(self):              
        self.baja = True                -> No se elimina, más bien se "da de baja"
        self.save()

    def restore(self):
        self.baja = False
        self.save()


----------------------- Ejemplos
Con el siguiente comando vemos el comando sql que hará..

    - python manage.py sqlmigrate cac 0001_initial              -> Vemos que sql se ejecutará

    - python manage.py migrate                                  -> Creamos la migración                



----------------------- Relaciones de muchos a muchos
Un curso tiene muchos estudiantes y un estudiante puede estar en varios cursos

<IMAGEN> img37

Creamos una tabla intermedio..

class Curso(models.model):
    estudiantes = models.ManyToManyField(Estudiante)            -> Solo debe ir en 1 de las 2 clases que estamos relacionando.. Resuelve lo de la tabla intermedia.


* Con Django Siempre escribimos clases..


-----------------------



class Curso(models.Model):
    nombre = models.CharField(max_length=100, verbose_name='Nombre')
    descripcion = models.TextField(null=True, verbose_name='Descripcion')
    fecha_inicio = models.DateField(verbose_name='Fecha de inicio')
    portada = models.ImageField(upload_to='imagenes/', null=True, verbose_name='Portada')
    categoria = models.ForeignKey(Categoria, on_delete=models.CASCADE)
    # estudiantes = models.ManyToManyField(Estudiante)                          -> O bien si tengo un curso, y vamos asociar a los estudiantes, lo hacemos desde acá..
                                                                                - Dependerá de la manera en la cual armamos el sistema.

class Estudiante(models.Model):
    nombre = models.CharField(max_length=100, verbose_name='Nombre')
    apellido = models.CharField(max_length=150, verbose_name='Apellido')
    cursos = models.ManyToManyField(Curso)                                      -> De esta manera el estudiante, está asociado a muchos cursos
                                                                                * Creamos una relación bidireccional de muchos a muchos con la clase definida..
                                                                                Muchos estudiantes con muchos cursos y muchos cursos con muchos estudiantes.


De esta manera Django genera la tabla intermedia que sirve de puente entre curso y estudiante..
    - python manage.py makemigrations               -> 

    - python manage.py migrate                      -> Al hacer el migrate crearemos una tabla extra, que estará relacionada.

*

----------------------- Ejemplo Práctico para agregar datos
Entramos a la shell..

    python manage.py shell_plus


    curso_3 = Curso(nombre="Otro")
    curso_3.save()
    estudiante = Estudiante(nombre="Maat")
    estudiante.save()

    estudiante.cursos.add(curso_3)          -> Creamos otra asociación.



----------------------- Relaciones de muchos a muchos
<IMAGEN> img38
Un curso tiene muchos estudiantes y un estudiante puede estar en varios cursos y
se desea registrar información sobre esa relación (la inscripción)


Generamos una clase intermedia, para guardar información extra..
    - through='Inscripcion'       -> Relacionamos para obtener la fecha de la Inscripcion
                                    - fecha = models.DateField()        
* De esta manera agregamos información extra a la relación..


----------------------- Relaciones de uno a uno
Un estudiante es una persona
<IMAGEN> img38

    -OneToOneField.. El Estudiante con la Persona.

----------------------- Ejemplo
class Persona(models.Model):
    nombre = models.CharField(max_length=100, verbose_name='Nombre')
    apellido = models.CharField(max_length=150, verbose_name='Apellido')


class Estudiante(models.Model):
    persona = models.OneToOneField(Persona, primary_key=True, on_delete=models.CASCADE)         -> Uno a Uno
    legajo = models.CharField(max_length=100, verbose_name='Legajo')

-----------------------
Entramos a la shell..

    python manage.py shell_plus



----------------------- Relaciones de uno a uno
Un estudiante es una persona
<IMAGEN> img40

----------------------- Relaciones de uno a uno (herencia)
<IMAGEN> img41

La Herencia la usamos desde Django, son maneras específicas.. Que usa Django.

----------------------- Clase base abstracta
<IMAGEN> img42

En este ejemplo, no existirá una Tabla Persona..
Tendremos Estudiante que usa a  Persona.
Tendremos Docente que usa a  Persona.

----------------------- Herencia de múltiples tablas
<IMAGEN> img43       No muy recomendad, ya que al traer datos, se hace más pesado.
La que acostumbramos a ver pero menos perfomante.


* Más registros, más lento..


----------------------- Modelos proxy
<IMAGEN> img44
El proxy le agrega responsabilidad a la clase pero no es persistida..
- Puede ser usada..
Digamos que le agrega más detalles a la clase base.



* Usar herencia solo cuando sea necesario..
Generalmente se usa la Clase Abstracta, para tener poca herencia.
Dependerá del proyecto.



----------------------- ¿Cómo interactúo con la BD?
Django brinda automáticamente una API de abstracción de base de 
datos que permite crear, recuperar, actualizar y eliminar objetos. Para 
la recuperación de objetos de la base de datos, se utiliza un QuerySet
vía un Manager de la clase de Modelo. Un QuerySet representa una 
colección de objetos de la base de datos

Todos los modelos, tienen un manager.. El Orm maneja la data de la base de datos.

----------------------- CRUD objetos
Crear Actualizar Eliminar.. A través del ORM
<IMAGEN> img45

----------------------- CRUD objetos
<IMAGEN> img46
Obtener

Persona.objects.all()       //  Con el .objects manager asociado al modelo, que pone el ORM encargado de interactuar con la Base de Datos.
Persona.objects.filter()        Son todos métodos del ORM para manejar 

-----------------------



-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 14. Models - 3 (Clase 23)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Models - 3
    ● Crud sobre modelos
    ● Integración de modelos con vistas y templates
    ● Vistas basadas en clases

 
----------------------- Recordemos
<IMAGEN> img47

Cada aplicación tiene sus propios modelos.. Se pueden relacionar a través de las vistas.

Por ejemplo, una aplicación para perfiles.. Con sus detalles.



CRUD            -> ABM alta, baja, modificación.
    Create
    Retrieve    -> Consultar
    Update
    Delete

Crud sobre los elementos de nuestro modelo.

----------------------- Retrieve
<IMAGEN> img48

Vemos la urls.. El view y el index, trabajando en conjunto.

DjangoAdmin es más sencillo para realizar la administración.


----------------------- Create
<IMAGEN> img49

A través de los formularios.. Al igual para el update

----------------------- Create

<IMAGEN> img50
Creamos el formulario en el nuevo.html, el template que tiene el form, que apunta con el action.

--- Ejemplo:
Clase 23... Armamos un admin para visualizarlo.

Las clases se diferencian para la sección de administración y para la sección pública.
Ambas aplicaciones estan dentro del proyecto separadas en el template.. Cada app tiene su propia base.


En el models.py de nuestra app cac.. Sobreescribimos el método str y además el save y el delete.. 
De esta manera, reescrbirimos o Sobreescribimos los métoodos Crud para el estudiante
from ast import mod
from email.policy import default
from tabnanny import verbose
from django.db import models


class Estudiante(models.Model):
    nombre = models.CharField(max_length=100, verbose_name='Nombre:')
    apellido = models.CharField(max_length=150, verbose_name='Apellido:')
    email = models.EmailField(max_length=150, verbose_name='Email:', null=True, default=None)
    dni = models.BigIntegerField(verbose_name='DNI:')
    # cursos = models.ManyToManyField(Curso)

    def __str__(self):
        return f"DNI: {self.dni} - {self.apellido}, {self.nombre}"

    def save(self, *args, **kwargs):
        if self.apellido.upper() == 'MESSI':
            raise ValueError("Messi es un maestro, no puede ser estudiante")                            -> No podremos guardar un estudiante como MESSI
        else:
            super().save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        if self.apellido.upper() == 'ALMADA':
            raise ValueError("No se puede eliminar, tiene mucho que aprender")
        return super().delete(*args, **kwargs)



En el views.py...

def estudiantes_index(request):
    estudiantes = Estudiante.objects.all().order_by('dni')                                                  -> Manejamos nuestro manager sobre el modelo Estudiante.. El .objects es el Manager.
     return render(request, 'cac/administracion/estudiantes/index.html', {'estudiantes': estudiantes})


    estudiantes = Estudiante.objects.all().selected_related('Curso').order_by('dni')                        -> selected_related podríamos traer data relacionada.   


    para acceder a la data relacionada, deberíamos hacer..
        - estudiante.cursos.first()             -> De esta manera accedemos a la data en relación


El queryset es LAZY     -> Es decir va en el último instante a la base de datos
                        -  Cuando sea necesaria la data,


Para el index.html del estudiante...

                {% for estudiante in estudiantes %}
                    <tr>
                        <td>{{estudiante.id}}</td>
                        <td>{{estudiante.nombre}}</td>
                        <td>{{estudiante.apellido}}</td>
                        <td>{{estudiante.dni}}</td>
                        <td>{{estudiante.email}}</td>
                        <td>
                            <a href="{% url 'estudiantes_editar' estudiante.id %}" title="Editar" class="btn btn-warning"><i class="fas fa-pencil"></i></a>         -> Para editar
                            <a href="{% url 'estudiantes_eliminar' estudiante.id %}" title="Eliminar" class="btn btn-danger"><i class="fas fa-trash"></i></a>       -> Apunta a esa url con el parámetro como id, para eliminar
                        </td>
                    </tr>
                {% endfor %}

----------------------- Sobreescribiendo modelo
<IMAGEN> img51


----------------------- ¿Qué son las Vistas Basadas en Clases?
Las vistas basadas en clases proporcionan una forma alternativa de 
implementar vistas como objetos de Python en lugar de funciones. No 
reemplazan las vistas basadas en funciones, pero tienen ciertas diferencias 
y ventajas en comparación con las vistas basadas en funciones:

• La organización del código relacionado con métodos HTTP específicos ( 
GET, POST, etc.) puede abordarse mediante métodos separados en lugar 
de bifurcaciones condicionales.
• Las técnicas orientadas a objetos, como mixins (herencia múltiple), se 
pueden usar para factorizar el código en componentes reutilizables.


Heredamos esas clases y las sobreescribimos..
+ Organizado y mejor orden. 


----------------------- Vistas basadas en clase (CBV)
CBV -> Class Base View

<IMAGEN> img52


--- Ejemplo Práctico

Desde el views.py..

from django.views.generic import ListView           -> Importamos

class EstudiantesListView(ListView):                -> Armamos la vista
    model = Estudiante                                              -> Le indicamos el contexto
    context_object_name = 'estudiantes'                             -> Marcamos el contexto..
    template_name = 'cac/administracion/estudiantes/index.html'     -> Lo asociamos al html
    # ordering = ['dni']                                            


Ahora desde el urls.py
    path('administracion/estudiantes', views.EstudiantesListView.as_view(), name='estudiantes_index'),      -> Con as_view llamamos al template.


Ahora desde el index.Html, apuntamos al nombre del contexto..
                {% for estudiante in estudiantes %}
                    <tr>
                        <td>{{estudiante.id}}</td>
                        <td>{{estudiante.nombre}}</td>
                        <td>{{estudiante.apellido}}</td>
                        <td>{{estudiante.dni}}</td>
                        <td>{{estudiante.email}}</td>
                        <td>
                            <a href="{% url 'estudiantes_editar' estudiante.id %}" title="Editar" class="btn btn-warning"><i class="fas fa-pencil"></i></a>
                            <a href="{% url 'estudiantes_eliminar' estudiante.id %}" title="Eliminar" class="btn btn-danger"><i class="fas fa-trash"></i></a>
                        </td>
                    </tr>
                {% endfor %}


También pordemos asociar el EstudiantesView lo asociamos con el Form:

Ahora en el views.py..

class EstudiantesView(View):
    form_class = EstudianteForm                                             -> Armamos el form.. 
    template_name = 'cac/administracion/estudiantes/nuevo.html'

    def get(self, request, *args, **kwargs):                                -> Podemos sobrescribir el metodo get y post
        form = self.form_class()                                            *  Nombramos al form que armamos.
        return render(request, self.template_name, {'formulario': form})

    def post(self, request, *args, **kwargs):
        form = self.form_class(request.POST)
        if form.is_valid():
            try:
                form.save()
            except ValueError as ve:
                form.add_error('apellido', str(ve))
            else:
                return redirect('estudiantes_index')

        return render(request, self.template_name, {'formulario': form})


Ahora de esta manera, armando por clase, queda más orientado a objetos..

----------------------- Vistas basadas en clase (CBV)
<IMAGEN> img53

-----------------------


-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 15. Models - 3 (Clase 24)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Models - 4
    ● Asociar un modelo a un formulario
    ● Seleccionando campos a utilizar
    ● Herencia de formularios



----------------------- Recordemos
<IMAGEN> img54

----------------------- ModelForm
<IMAGEN> img55
Creamos un formulario que hereda de ModelForm.. Clase que procee de Django

    Debemos especificar el model al cual el formulario está asociado..
    Y que campos queremos que aparezcan

* Debemos corroborar lo que tenemos en el modelo con lo que especificamos en el Formulario.

from django import forms        -> Debemos importar el forms

# class EstudianteForm(forms.ModelForm):
#     class Meta:
#         model = Estudiante                     
#         fields = '__all__'                    -> All, salvo la primary key.. 
                                                *  No es correcto usar el __all__
                                                ('apellido', 'nombre', 'email', 'dni')  -> Mejor especificar cada uno de los campos
                                        *Mejor especificar los campos.

            exclude = ('email')                 -> Otra manera es excluir el email.



----------------------- ModelForm
<IMAGEN> img56


----------------------- ModelForm
<IMAGEN> img57

Validaciones del formulario, asociada al modelo.
De esta manera podemos laburar en cada input de manera separada y específica.

----------------------- Herencia de Formularios
<IMAGEN> img58

El formulario EstudianteFormValidado hereda de EstudianteForm, todos los campos..
Y además agregamos la validación.


--- Ejemplo: En el forms.py

class EstudianteForm(forms.ModelForm):
    nombre = forms.CharField(error_messages={'required': 'PONE EL VALOOR'})
    
    class Meta:
        model = Estudiante
        fields = '__all__'    
        widgets = {
            'apellido': forms.Textarea(attrs={'cols': 20, 'rows': 20}),
        }
        error_messages = {
            'email': {
                'required': 'Y EL VALOR QUE ONDA?',
            },
        }


class EstudianteFormValidado(EstudianteForm):
    def clean_apellido(self):
        apellido = self.cleaned_data['apellido']
        if apellido.upper() == "MESSI":
            raise ValidationError("Messi no es estudiante")

        return apellido


Ahora en al views.py le especificamos que usaremos el EstudianteFormValidado.. Lo demás queda igual
La validación la ejecutará antes de ir a grabar al modelo..

class EstudiantesView(View):
    form_class = EstudianteFormValidado                                 -> Acá mismo
    template_name = 'cac/administracion/estudiantes/nuevo.html'

    def get(self, request, *args, **kwargs):
        form = self.form_class()
        return render(request, self.template_name, {'formulario': form})

    def post(self, request, *args, **kwargs):
        form = self.form_class(request.POST)
        if form.is_valid():
            form.save()
            return redirect('estudiantes_index')

        return render(request, self.template_name, {'formulario': form})


* La validaciones las podemos hacer desde el formulario, en esta situación usando la herencia..
O bien desde el propio modelo..


Es decir en el models.py
class Estudiante(models.Model):
    nombre = models.CharField(max_length=100, verbose_name='Nombre:')
    apellido = models.CharField(max_length=150, verbose_name='Apellido:')
    email = models.EmailField(max_length=150, verbose_name='Email:', null=True, default=None)
    dni = models.BigIntegerField(verbose_name='DNI:')

    def __str__(self):
        return f"DNI: {self.dni} - {self.apellido}, {self.nombre}"

    def save(self, *args, **kwargs):
        if self.apellido.upper() == 'MESSI':                                                -> Hacemos la validación en el propio modelo.
            raise ValueError("Messi es un maestro, no puede ser estudiante")
        else:
            super().save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        if self.apellido.upper() == 'ALMADA':
            raise ValueError("No se puede eliminar, tiene mucho que aprender")
        return super().delete(*args, **kwargs)


Además podemos mejorar aún más la forma de escribir el forms...
De esta manera tenemos más personalizados.. 

class EstudianteForm(forms.ModelForm):
    nombre = forms.CharField(error_messages={'required': 'PONE EL VALOOR'})             -> Personalizar ese campo con el required
    
    class Meta:
        model = Estudiante                      * Esto esta todo mezclado, mejor elegir si definimos el campo como arriba o usamos la etiqueta meta    
        fields = '__all__'    
        widgets = {
            'apellido': forms.Textarea(attrs={'cols': 20, 'rows': 20}),     -> O el text area a través del widgets
        }
        error_messages = {
            'email': {
                'required': 'Y EL VALOR QUE ONDA?',                         -> Otra manera es a través del Meta, podemos manejar el error
            },
        }


class EstudianteFormValidado(EstudianteForm):
    def clean_apellido(self):
        apellido = self.cleaned_data['apellido']
        if apellido.upper() == "MESSI":
            raise ValidationError("Messi no es estudiante")

        return apellido


En el settings.py... Para manejar el idioma en español.

LANGUAGE_CODE = 'es-ar'

----------------------- Sobreescribiendo formularios
<IMAGEN> img59


También desde form_campos.html... Dependerá como presentamos la data.

{% for campo in formulario %}
    <div class="form-group">
        <label for="">{{campo.label}}</label>
      
        {% comment %} {{campo}} {% endcomment %}
        <input 
            type="{{campo.field.widget.input_type}}" 
            name="{{campo.name}}" 
            id="{{campo.name}}"
            class="form-control"
            placeholder="Ingrese {{campo.name}}"
            value="{{ campo.value | default:'' }}"
        >
    </div>
    <div>{{campo.errors}}</div>
{% endfor %}
<div class="row mt-3">
    <div class="col-12">
        <input type="submit" value="Guardar" class="btn btn-success">
        <a href="javascript:history.back();" class="btn btn-secondary">Cancelar</a>        
    </div>
</div>




* La entidad del modelo debe venir en Singular
* Considerar los Plugins de Django, "las mayorías" de cosas están hechas.

-----------------------
----------------------- 
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 16. Django: Admin - 1 (Clase 26)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Admin - 1
    ● Que es el DjangoAdmin
    ● Configuración del DjangoAdmin
    ● Creación del superusuario
    ● Integrando modelos al DjangoAdmin

----------------------- ¿Qué es el Django Admin?
Una de las partes más poderosas de Django es la interfaz de 
administración automática. Lee los metadatos de los modelos para 
proporcionar una interfaz rápida y centrada en el modelo donde los 
usuarios de confianza pueden administrar el contenido de su sitio. La 
herramienta se encuentra enfocada en la administración interna del 
sistema por parte de un administrador pero no está pensada para el 
usuario final. Su intención no es armar un front-end completo de 
administración

* Está integrada y la podemos sacar si es necesario.


----------------------- Configurable
<IMAGEN> img60 
Con colores, estilos y demás.. 


----------------------- Configuración inicial necesaria (por defecto con startproject)
<IMAGEN> img61

Cuando comenzamos con el proyecto se instala el django admin.

- Si vemos el django encontramos el contrib - > Admin




----------------------- Configuración inicial necesaria (por defecto con startproject)
<IMAGEN> img62

Los middlewares es código que se ejecuta ANTES de que llegue a nuestro sitio..
Entre que ingresa al server y llega a nuestro backend.

                            -> admin, podemos poner el nombre que deseemos
Debemos agregar o linkear la url de admin/, admin.site.urls..

----------------------- Configuración inicial
<IMAGEN> img63

* Por lo cual podremos tener dos administraciones.. El propio de la página y el admindjango.

Desde consola:
    - python manage.py createsuperuser          -> Definimos el nombre del usaurio.
    
    Este usuario lo usamos dentro del django_admin..
        is_stafs   -> El que tiene más privilegios, si es True, entra

* Para el lenguaje, recordar el LANGUAGE_CODE = 'es-ar' -> Castellano argentino


---- Ejemplo Práctico

from django.contrib import admin
from cac.models import Estudiante, Comision             -> Registramos nuestros modelos con la interfaz del Django Admin


class EstudianteAdmin(admin.ModelAdmin):
    pass


admin.site.register(Estudiante, EstudianteAdmin)        -> Acá además agregamos la comision
# admin.site.register(Comision)                         -> Con esta linea agregamos al Admin el Modelo de Estudiante

@admin.register(Comision)
class ComisionAdmin(admin.ModelAdmin):
    pass


--- Además dentro de los models.py sobreescribimos el __str__ para visualizar la data de manera más clara..

class Estudiante(models.Model):
    nombre = models.CharField(max_length=100, verbose_name='Nombre:')
    apellido = models.CharField(max_length=150, verbose_name='Apellido:')
    email = models.EmailField(
        max_length=150, verbose_name='Email:', null=True, default=None)
    dni = models.BigIntegerField(verbose_name='DNI:')
    comision = models.ForeignKey(Comision, on_delete=models.SET_NULL, null=True)

    class Meta:
        verbose_name_plural = "Estudiantes"

    def __str__(self):
        return f"DNI: {self.dni} - {self.apellido}, {self.nombre}"          -> De está manera visualizamos la data en Django Admin







----------------------- Configuración inicial
<IMAGEN> img64

----------------------- Y los modelos?
<IMAGEN> img65

----------------------- Registro modelos
<IMAGEN> img66

----------------------- Registro modelos


----------------------- Registro modelos

----------------------- Registro modelos

-----------------------

Además si en el models.py... Agregamos la Comisión y el Estudiante

from ast import mod
from email.policy import default
from tabnanny import verbose
from django.db import models


class Comision(models.Model):                                                           -> Comision
    nombre = models.CharField(max_length=150, verbose_name='Comsion:')                  *  Cada charField va pensado con detenimiento de antemano.
    imagen = models.ImageField(verbose_name="Imagen:", default=None, null=True)                 -> Esto es para la imagen.

    class Meta:
        verbose_name_plural = "Comisiones"                      -> Podemos decirle al modelo como se  nombrará en plural.
                                                                *  Para ordenarlos a criterio podemos usar  verbose_name_plural = " 01 - Comisiones"        -> Forma simple para reorganizar.
    def __str__(self):                                                            Y en la otra clase usar   verbose_name_plural = " 02 - Estudiantes"       *  O dejarlo sin el num, para legibilidad.
        return self.nombre

    def delete(self):
        self.imagen.delete()                                    -> ESTO ES PARA ELIMINAR LA IMAGEN
        return super().delete()                                 *  Borramos la imagen ANTES de eliminar la comisión/la entidad


class Estudiante(models.Model):                                                         -> Estudiante
    nombre = models.CharField(max_length=100, verbose_name='Nombre:')
    apellido = models.CharField(max_length=150, verbose_name='Apellido:')
    email = models.EmailField(
        max_length=150, verbose_name='Email:', null=True, default=None)
    dni = models.BigIntegerField(verbose_name='DNI:')
    comision = models.ForeignKey(Comision, on_delete=models.SET_NULL, null=True)            * La comisión está asociada a la comision
                                                                                            * on_delete=models.SET_NULL no en cacade, dejaremos nulos de ser necesario.
    class Meta:
        verbose_name_plural = "Estudiantes"

    def __str__(self):
        return f"DNI: {self.dni} - {self.apellido}, {self.nombre}"

    def save(self, *args, **kwargs):
        if self.apellido.upper() == 'MESSI':
            raise ValueError("Messi es un maestro, no puede ser estudiante")
        else:
            super().save(*args, **kwargs)

    def delete(self, *args, **kwargs):
        if self.apellido.upper() == 'ALMADA':
            raise ValueError("No se puede eliminar, tiene mucho que aprender")
        return super().delete(*args, **kwargs)


--- Ahora en el Admin.py

from django.contrib import admin
from cac.models import Estudiante, Comision


class EstudianteAdmin(admin.ModelAdmin):
    pass


admin.site.register(Estudiante, EstudianteAdmin)            -> EstudianteAdmin, manejamos un admin específico para ese Admin
# admin.site.register(Comision)

@admin.register(Comision)
class ComisionAdmin(admin.ModelAdmin):
    pass



Por lo tanto el Django Admin será más para el usuario de Sistema..
El otro admin más para el usaurio final.




* Para sibur una imagen...
desde settings.py

MEDIA_URL = 'media/'
MEDIA_ROOT = BASE_DIR / 'media'                 -> La carpeta media, la debemos crear...
                                                * Para borrar la imagen del lugar fisico, le especificamos el método delete.

-----------------------

-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 17. Personalizando el Django Admin y relaciones muchos a muchos con tabular inline (Clase 27)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Admin - 2
    ● Modelos muchos a muchos
    ● Personalizando DjangoAdmin

 
----------------------- Modelos muchos a muchos
<IMAGEN> img67

    ManyToManyField -> Donde lo decidimos poner.. Genera una tabla intermedia.


*Un estudiante puede pertenecer a muchas comisiones..
Una comision puede tener muchos estudiantes

----------------------- Modelos muchos a muchos
<IMAGEN> img68

    __str__ para mostrar el modelo en concreto..
            * La representación en String.


----------------------- Modelos muchos a muchos
<IMAGEN> img69

--- Ejemplo práctico.

    django.contrib.admin        -> Instalada.



* Para sobreescrir el Django Admin..


class EstudianteAdmin(admin.ModelAdmin):
    list_display = ('legajo', 'apellido', 'nombre')         -> Manera de visualizar el modelo en el Djangoadmin
    # list_editable = ('apellido', 'nombre')                -  Para tener campos editables o no
    list_display_links = ('legajo',)                        -  Botones cickleabes
    search_fields = ['apellido']                            -  Para buscar dentro de apellido



class DocenteAdmin(admin.ModelAdmin):               
    list_display = ('cuit', )
    form = DocenteForm                                      -> Para ver un form, para agregar el Docente


--- Otra manera, con los decoradores


@admin.display(description='Nombre del curso en mayuscula')
def curso_mayuscula(objeto):
    return f"El Curso {objeto.nombre}".upper()                  -> De esta manera especificamos la data en mayúscula
                                                                *  Son como "etiquetas" que no afectarán el modelo.

@admin.register(Curso)                          -> modelo que se registra para el curso
class CursoAdmin(admin.ModelAdmin):
    # formfield_overrides = {
    #     models.TextField: {'widget': widgets.CacTextWidget}
    # }
    list_display = (curso_mayuscula, 'curso_minuscula', )               -> De esta manera podemos modificar la manera de mostrar los elementos

    @admin.display(description='Nombre del curso en minuscula')
    def curso_minuscula(self, objeto):                                  -> En minúscula, le agregamos además el nombre de las columnas
        return f"Curso {objeto.nombre}".lower()



--- Un model @admin, asociado a un modelo se registra una única vez..

@admin.register(Comision)
class ComisionAdmin(admin.ModelAdmin):
    list_display = ('nombre', 'fecha_inicio', )                                 -> Columnas a mostrar
   
    def formfield_for_manytomany(self, db_field, request, **kwargs):            -> Sobreescribimos el método de obtener el mucho a muchos.
        if db_field.name == "estudiantes":
            kwargs["queryset"] = Estudiante.objects.filter(legajo__startswith="2").order_by("apellido")
        return super().formfield_for_manytomany(db_field, request, **kwargs)



--- Para configurar nuestro pgAdmin

INSTALLED_APPS = [
    #  'django.contrib.admin',  # Utiliza el autodiscover para obtener el admin de todas las aplicaciones en "INSTALLED_APPS"
    'django.contrib.admin.apps.SimpleAdminConfig',  # No utiliza el autodiscover se debe hacer todo a mano"
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django_extensions',
    'cac'
]


Ahora desde el admin.py...


class CacAdminSite(admin.AdminSite):                        -> Modificamos el formato del django admin, como se mostrarán los titulos y demas.
    site_header = "Administración de Codo a Codo"
    site_title = "Administración para super usuarios"
    index_title = "Administrador del Sitio"
    empty_value_display = "No hay nada"



Instanciamos el objeto de arriba.. Y le registramos los modelos..


sitio_admin = CacAdminSite(name='cacadmin')             -> Instanciamos
sitio_admin.register(Docente)
sitio_admin.register(Curso)                             - Registramos los modelos
sitio_admin.register(Estudiante, EstudianteAdmin)
sitio_admin.register(Comision, ComisionAdmin)


--- Ahora desde las urls.py debemos importar el sitio_admin

from django.contrib import admin
from django.urls import path
from django.urls.conf import include
from cac.admin import sitio_admin                   -> Importamos


urlpatterns = [
    path('cac_admin/', sitio_admin.urls),           -> Lo agregamos
                                                    * Podriamos agregar diferentes rutas para mostrar o obviar diferente información.
    # path('super_admin/', admin.site.urls),
    path('', include('cac.urls'))
]

--- Sobreescribir el Html del django Admin..
Agregamos el templates en la raíz del proyecto.. Agregamos la carpeta admin, y un base.html


{% extends 'admin/base.html' %}

{% block extrastyle %}{{ block.super }}
<style>
:root {
  --primary: #9774d5;
  --secondary: #785cab;
  --link-fg: #7c449b;                   -> Agregamos estilos de Css al Django Admin.
  --link-selected-fg: #8f5bb2;
}
</style>
{% endblock %}


--- 
# nuestro propio sitio admin
from django.contrib import admin
from cac.models import Estudiante, Docente, Curso, Comision, Inscripcion

class CacAdminSite(admin.AdminSite):
    site_header = "Administración de Codo a Codo"
    site_title = "Administración para super usuarios"
    index_title = "Administrador del Sitio"
    empty_value_display = "No hay nada"

# Versión 1: si definimos un modelo intermedio
class InscripcionInline(admin.TabularInline):
    model = Inscripcion
    extra = 1

# # Versión 2:si no tenemos un modelo intermedio (cambia la asociación del inline en admins)
# class InscripcionInline(admin.TabularInline):                     - La tabla intermedia, hereda de TabularInline
#     model = Comision.estudiantes.through
#     extra = 1  # cuantas opciones de carga aparecen por defecto


class EstudianteAdmin(admin.ModelAdmin):
    list_display = ('legajo', 'apellido', 'nombre')
    list_display_links = ('nombre', 'apellido', )
    fields = (('nombre', 'apellido'), 'legajo')  # Si no hacemos un valor editable debe manejarse dicha situación de alguna manera.
    # ambas versiones
    inlines = (InscripcionInline, )             -> Hereda de InscripcionInline


class ComisionAdmin(admin.ModelAdmin):
    # ambas versiones
    inlines = (InscripcionInline, )
    # version 2 evitamos doble carga
    exclude = ('estudiantes', )                 -> Excluimos 


* Con el TabularInline -> Nos queda de manera dinámica todo enganchado y utilizable.


--- Ahora en el models.py

class Comision(models.Model):
    class Meta:
        verbose_name_plural = _("Comisiones")

    nombre = models.CharField(max_length=100, verbose_name='Nombre')
    descripcion = models.TextField(null=True, verbose_name='Descripcion')
    fecha_inicio = models.DateField(verbose_name='Fecha de inicio')
    portada = models.ImageField(upload_to='imagenes/comisiones/', null=True, verbose_name='Portada', default=None)
    curso = models.ForeignKey(Curso, on_delete=models.CASCADE)
    docente = models.ForeignKey(Docente, on_delete=models.SET_NULL, null=True)
    # version 1 admin
    estudiantes = models.ManyToManyField(Estudiante, through='Inscripcion')                     -> Si con la tabla intermedia DEFINIDA, Inscripcion, con esa tabla hacemos la relación
    # version 2 admin
    # estudiantes = models.ManyToManyField(Estudiante)

    def __str__(self):
        return self.nombre

    def delete(self, using=None, keep_parents=False):
        self.portada.storage.delete(self.portada.name)  # borrado fisico de la imagen
        super().delete()


class Inscripcion(models.Model):                                                                -> Esta tabla hará la relación
    class Meta:
        verbose_name_plural = _("Inscripciones")

    class Estado(models.IntegerChoices):
        INSCRIPTO = 1
        CURSANDO = 2
        EGRESADO = 3

    fecha_creacion = models.DateField(verbose_name='Fecha de creación')
    estudiante = models.ForeignKey(Estudiante, on_delete=models.CASCADE)
    comision = models.ForeignKey(Comision, on_delete=models.CASCADE)
    estado = models.IntegerField(choices=Estado.choices, default=Estado.INSCRIPTO)
    # opción sin crear la clase interna Estado
    # estado = models. IntegerChoices("Estado", 'INSCRIPTO CURSANDO EGRESADO')

    def __str__(self):
        return self.id



# Versión 1: si definimos un modelo intermedio
class InscripcionInline(admin.TabularInline):
    model = Inscripcion                                                 -> Ahora si tenemos la tabla intermedia
    extra = 1

# # Versión 2:si no tenemos un modelo intermedio (cambia la asociación del inline en admins)
# class InscripcionInline(admin.TabularInline):
#     model = Comision.estudiantes.through
#     extra = 1  # cuantas opciones de carga aparecen por defecto


* De esta manera tendremos un TabularInline, con una tabla definida.


----------------------- Modelos muchos a muchos
<IMAGEN> img70

----------------------- Personalizando el sitio por defecto del DjangoAdmin
<IMAGEN> img71

----------------------- Personalizando el sitio por defecto del DjangoAdmin
<IMAGEN> img72


----------------------- Personalizando nuestro DjangoAdmin
<IMAGEN> img73

----------------------- Personalizando nuestro DjangoAdmin
<IMAGEN> img74

-----------------------
-----------------------
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 18. Django Authentication  Autenticación y autorización desde Django (Clase 28)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Autenticación - 1
● Autenticación vs Autorización
● Instalación
● Usuarios y Grupos
● Is_authenticated
● Decorator login_required
● Limitar acceso en templates


----------------------- Autenticación y Autorización
<IMAGEN> img75

Autenticación   -> Quien soy your
    Se, tengo, soy  factores básicos.

Autorización    -> Que puedo hacer

----------------------- ¿Qué es Django Authentication?
<IMAGEN> img76

Autentica y autoriza, django auth.

----------------------- Configuración
<IMAGEN> img77


----------------------- Objeto User
<IMAGEN> img78

Con sus respectivos atributos


----------------------- Objeto User
<IMAGEN> img79

Usamos el manager    -> .objects

is_staff   -> si está en un True, entrá al Django Admin

----------------------- Contraseñas
<IMAGEN> img80

Las constraseñas cuando se ingresan, se hashean..

El hash que se encuentra en la base de datos.. Es comparado con el hash creado al momento de iniciar sesión.
Si son iguales, está okey.. Todo esto es configurable



----------------------- Autenticando usuarios
<IMAGEN> img81

Autenticar no quiere decir loguearse.. Autenticar es Validar si es correcto el usuario y contraseña.
Loguearse es guardar el usuario y la contraseña en la sesión, 


----------------------- Permisos y Autorización
<IMAGEN> img82

Esto es importante, dedicarle el tiempo para saber quien hace que y con que alcance.

----------------------- Permisos y Autorización
<IMAGEN> img83

----------------------- Permisos y Autorización
<IMAGEN> img84

----------------------- Permisos y Autorización
<IMAGEN> img85
-----------------------
<IMAGEN> img86

El form para agregar usuario, se puede usar también en el Front.

----------------------- Iniciar y cerrar sesión en un usuario

<IMAGEN> img87

Acá vemos la diferencia entre autenticar y loguear.. Con el login, le pasamos el request y el user.

Con el logout(request)  deslogueamos al usuario.

----------------------- Limitar acceso a usuarios registrados en vistas

<IMAGEN> img88
----------------------- Limitar acceso a usuarios registrados en vistas basadas en clases


<IMAGEN> img89
----------------------- Limitar acceso a vistas basadas según permisos

<IMAGEN> img90
----------------------- Limitar acceso a usuarios registrados en templates

También podemos hacerlo desde el template y desde la vista..


<IMAGEN> img91
----------------------- Limitar acceso a permisos en templates

<IMAGEN> img92

----------------------- Ejemplo práctico

En el settings.py..

INSTALLED_APPS = [
    #'django.contrib.admin',  # Utiliza el autodiscover para obtener el admin de todas las aplicaciones en "INSTALLED_APPS"
    'django.contrib.admin.apps.SimpleAdminConfig',  # No utiliza el autodiscover se debe hacer todo a mano"
    'django.contrib.auth',                          -> Corroboramos el auth
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django_extensions',
    'cac'                                           -> Nuestra app
]

--- En el html, index.. Mostramos o no los usuarios.

    {% if user.Is_authenticated %}          -> De esta manera debajo mostramos toda la data necesaria.  


--- Ahora desde la views.py
from django.contrib.auth import authenticate, login, logout


def cac_login(request):
    if request.method == 'POST':
        # AuthenticationForm_can_also_be_used__
        username = request.POST['username']
        password = request.POST['password']
        user = authenticate(request, username=username, password=password)              -> Con el authenticate
        if user is not None:
            form = login(request, user)
            messages.success(request, f' Bienvenido/a {username} !!')
            return redirect('inicio')
        else:
            messages.error(request, f'Cuenta o password incorrecto, realice el login correctamente')
    
    form = AuthenticationForm()
    return render(request, 'cac/publica/login.html', {'form': form, 'title': 'Log in'})


--- Ahora desde la urls.py configuramos el logout.. 

    path('cuentas/logout/',
         auth_views.LogoutView.as_view(template_name='cac/publica/index.html'), name='logout'),

--- Ahora desde la urls.py configuramos el login y register.. Basado en vista en clase.
 
    path('', views.index, name='inicio'),
    # path('accounts/', include('django.contrib.auth.urls')),
    path('cuentas/registrarse', views.cac_registrarse, name='registrarse'),
    path('cuentas/login', views.cac_login, name='login'),
 

-----------------------
-----------------------

-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 19. 
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------

Django: Authentication - 2
    ● Configurando vistas y  templates de django.contrib.auth por defecto
    ● Login de usuarios
    ● Logout de usuarios
    ● Modificación de usuarios

----------------------- Configurar urls de autenticación por defecto
Usaremos vistas basadas en clase.. Es más sencillo para sobreescribir algo.


<IMAGEN> img93

Si registramos la url accounts/ nos provee todo de manera automática, menos el register..

    accounts/login      -> De esta manera manejamos de manera automática y están relacionadas
    accounts/logout


----------------------- Urls y nombres generados por defecto

<IMAGEN> img94

Estas son generedas de manera automáticas.. VBC -> Vistas basadas en clases.

* De esta manera, también podemos configurar el reseto de password..

Con tan poco se puede crear mucho.

----------------------- Vistas de autenticación
<IMAGEN> img95

La de Login -> la loginView, tiene atributos y responsabilidades.

redirect_field_name -> Redireccion de la pagina

template_name -> indica en que lugar estará el login.html


--- Ejemplo práctico

En el urls.py... Vemos las urls de las accounts..

urlpatterns = [
    # accounts/login/ [name='login']
    # accounts/logout/ [name='logout']
    # accounts/password_change/ [name='password_change']                            -> Podemos elegir cual agregar y cual no
    # accounts/password_change/done/ [name='password_change_done']
    # accounts/password_reset/ [name='password_reset']
    # accounts/password_reset/done/ [name='password_reset_done']
    # accounts/reset/<uidb64>/<token>/ [name='password_reset_confirm']
    # accounts/reset/done/ [name='password_reset_complete']
    path('accounts/password_change/', auth_views.PasswordChangeView.as_view(success_url="/"), name='password_change'), 
    path('accounts/registrarse', views.cac_registrarse, name='registrarse'),
    # path('accounts/login', auth_views.LoginView.as_view(template_name="cac/publica/login.html"), name='login'), 
    path('accounts/', include('django.contrib.auth.urls')),
    # path('cuentas/login', views.cac_login, name='login'),
 

--- Le indicamos en el settings.py


# REGISTRATION
LOGIN_REDIRECT_URL = "inicio"           -> Donde redirigimos después del login y el logout
LOGOUT_REDIRECT_URL = "inicio"          -> Le indicamos el nombre del path de la url
                                        Que es esta:
                                                path('', views.index, name='inicio')



--- Debemos agregar la carpeta dentro del templates llamado "registration" y el login.html
Si no existe, lo generamos.. Si existe lo sobrescribimos

El template se hará de acuerdo a lo sugerido por Django

    path('accounts/', include('django.contrib.auth.urls')),         -> Al incluir los templates por defecto, irá a buscar esa plantilla en específico

Al poner el login.html  que es el archivo base.


----------------------- Vistas de autenticación
<IMAGEN> img96

--- O bien podemos una especificamente, no de manera general como la anterior.

    # path('accounts/login', auth_views.LoginView.as_view(template_name="cac/publica/login.html"), name='login'), 

----------------------- Vistas de autenticación
<IMAGEN> img97

Luego vemos el logout.. Va a una vista, saca de sesión al usuario.


* Podemos usar el cambio de contraseña por defecto, usando la plantilla por defecto Django..
Con pocas líneas tenemos toda la autenticación por defecto.

----------------------- Extendiendo el Usuario
<IMAGEN> img98

2 maneras, generalmente se extiende el modelo existente..

El perfil de visualización, datos extras, es uno a uno con el usuario.. EL usuario maneja la autenticación.


Para abstraer el User, podemos agregarle nuevas propiedades o funcionalidades..
Usando el nuevo modelo.

-----------------------
De esta manera exigimos el login..

# @login_required
# def mi_vista(request):
#     ...


O bien extendemos del login en la vista base en clases..

# from django.contrib.auth.mixins import LoginRequiredMixin

# class MiVista(LoginRequiredMixin, View):
#     login_url = '/login/'
#     redirect_field_name = 'redirect_to'
#    


-----------------------
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 20. Django: Rest Framework (Clase 31)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Rest Framework
    ● WebSite vs WebApi
    ● Serializadores
    ● Instalación y configuración django rest framework
    ● Authenticación
    ● Routers
    ● Vista

Para generar una Api dentro del sitio..
No orientado a microservicios.

Nuestra Api le brinda información a otro sistema.
Con una aplicación de Django, podemos proveer un servicio.

----------------------- Recordemos
<IMAGEN> img99

* 

----------------------- REST API Model
<IMAGEN> img100

Con este tipo de modelo.. Tenemos un PUNTO DE ENTRADA.. El cual se comunicará con el servidor.
Es el endpoint, la api está dentro del server.

No es una arquitectura, es una manera de modelar una Api.
También están las SOAP, son "Metodologías"..


¿Para que se piensa?
Es un punto donde se recibe un solocitud un request, y emitimos una respuesta, un response.
Lo que recibe el cliente:
    - json  -> Más independiente de la tecnlogía.
    - xml
    - html

Es una manera de pensar una arquitectura, empleando Rest Api, para permitir servicios, antes eran Soap.


----------------------- Modelos combinados
<IMAGEN> img101

La página está creada en HTML y..
La api la proveemos para un sitio externo, que puede ser un celular, un banco, etc.. 
    - De esta manera permitimos a través del framework para comunicar con otros servicios.
    - Podría existir o no.


En la página, proveemos un endpoint para mostrar a los estudiantes.
    - Por medio de la api se puede hacer un post, un get, etc.. Dependerá de la lógica de negocio.


----------------------- Instalación
<IMAGEN> img102

    djangorestframework -> Con el pip en el entorno..

    La debemos agregar en las app instaladas.

    Y debemos agregar las urls que deseemos manejar..
        - Por defecto, crea una api para autenticar.. Responde con el user.
        - Además crea la parte visual.

    * Autenticación con Token es lo más utilizado.. Lo anterior no tanto.



----------------------- Serialización
<IMAGEN> img103

Transformar un objeto, en un string (Texto), algo serializable..
Que puede ser transportado a través de HTTP..

Serializar: Agarramos el objeto lo pasamos a un string
Desserializamos: Agarramos el String y lo pasamos a un objeto.

¿Que objeto? Dependerá de la tecnlogía..

Server, objetos de python, de django, modelos.. Todo esto lo transforma y lo envía al cliente.




----------------------- Ejemplo práctico
<IMAGEN> img104



--- Ejemplo

No usaremos microservicios..
De esta manera no individualizamos sino más bien acoplamos la Api al website.


Generamos la app de django..
    - django-admin startapp cac_api

        - serializer    ->
        - urls.py       -> Punto de entrada a nuestra Api.
        - views.py      -> Funciones que reciben la llamada de la URL.



----------------------- Serializers.py
<IMAGEN> img105

    - Que hace? Transforma el objeto a un string o al revés.
Ya viene todo armado.. De esta manera asociamos el modelo con el ModelSerializer

En este ejemplo vemos asociado el modelo con la api.. O sea, ese acoplamiento y no usando la estructura de microservicios.

--- 


----------------------- Views.py (ViewSets)
<IMAGEN> img106

Usamos las vistas que provee el framwork.. Vistas basadas en calse, VBC

    EstudianteMViewSer -> Nombre elegido arbitrariamente con relación al modelo.

    El queryset lo manejamos a través del manager.. objects.

    nos traemos el serializer.EstudianteMSerializer

    permission_classes ->   Si la vista tiene o no seguridad..
                            En el ejemplo exigimos la autenticación y que sea read only


* De esta manera generamos las vistas para obtener lo que sea necesario de acuerdo a los estudiantes..
Obtenerlos todos, algunos, uno solo y etc..


----------------------- Urls.py (Routers)
Ahora con las vistas creadas.. Registradas a través de la vista basada en Clase ModelViewSet..
Procedemos armar las urls..

<IMAGEN> img107 

con el router.. Genera todo de manera automática..
    - Es decir vistas asociadas a urls.. de listar, grabar uno, actualizar uno, etc.
    


--- Ejemplo Práctico
Generamos nuestra app_api..


--- serializers.py
from rest_framework import serializers
from cac.models import EstudianteM          -> Importamos desde el modelo del cac


class EstudianteMSerializer(serializers.ModelSerializer):                                   -> Hereda del framework
    class Meta:
        model = EstudianteM                                                                 -> Asociado al EstudianteM
        fields = ['id', 'nombre_m', 'apellido_m', 'email_m', 'dni_m', 'matricula_m']        * El modelo es que tenemos en nuestro proyecto general.
                                                                                            * 
    


--- urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from cac_api import views

router = DefaultRouter()
router.register(r'estudiantes', views.EstudianteMViewSet, basename='estudiante')            -> De manera automática nos traemos todas

urlpatterns = [                                                                             * O bien, especificando las url de manera manual..
    path('', include(router.urls)),                                                         -> Agregamos las urls de manera automática
    path('api-auth', include('rest_framework.urls', namespace='rest_framework'))            -> Genera la capa de autenticación automática
]



--- views.py
from rest_framework import viewsets
from rest_framework import permissions
from cac.models import EstudianteM
from cac_api import serializers


# Create your views here.
class EstudianteMViewSet(viewsets.ModelViewSet):
    queryset = EstudianteM.objects.all().order_by('id')                 -> Acá podemos hacer los filtros y los cambios necesarios en la info que traemos.
    serializer_class = serializers.EstudianteMSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

--- Ahora en el pig_22820/urls.py

from django.contrib import admin
from django.urls import path
from django.urls.conf import include
from cac.admin import mi_admin
from cac_api import urls as api_urls                    -> Lo nombramos como api_urls

urlpatterns = [
    path('cac_api/', include(api_urls)),                -> Linkeamos la api
    path('cacadmin/', mi_admin.urls),
    path('admin/', admin.site.urls),
    path('', include('cac.urls'))
]





----------------------- Ejemplo práctico (interfaz automática)
<IMAGEN> img108

    localhost:8000/cac_api/            -> Nos genera el endpoin de nuestra base de datos.

    - Ahora si apuntamos con el postman a esa url.. Aplicamos los verbos HTTPS


    Para hacer un post, es necesario hacer la autenticación.. De lo contrario solo usamos el get.


    localhost:8000/cac_api/         -> Si vamos al login, 
        - Ponemos el usuario y la contraseña.. Iniciamos y podemos entrar con el Post.
        - Si fuese necesario.. Podemos hacer el put a través del id de los elementos.. También el Delete.

    * De esta manera nos provee toda una interfaz gráfica..

-----------------------

Si quisieramos hacerlo desde el frontend.. Podemos hacer un fetch usando js..
-- Por ejemplo
const divProyectos = document.querySelector("#divProyectos");

fetch('/api_proyectos')                                         -> Le armamos 
  .then((response) => response.json())
  .then((data) => {
    console.log(data);
    let proyectos = data.data;
    proyectos.forEach(proyecto => {
        let html = renderProyecto(proyecto);
        divProyectos.insertAdjacentHTML('beforeend', html);
    });
  });

-----------------------
Usar un plugins o el framework view para que desde la vista.. Podemos consumir la api.
O bien el propio Django..
    
    import requests

    respuesta = requests.get("https://api")         -> La requests la podemos manejar a gusto.. Que mostrar y demás.
                                                    * Esto se hace en la views.py, el tiempo de respuesta puede variar y el servidor se puede caer.
                                                    * AWS es gratis, pero c


De esta manera con un serializer para mostrar la información de acuerdo a lo necesario.

También hay que considerar el asincronismo al momento de manejar las Apis.. Hacer el await y demás.

-----------------------



-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
1| 21. Django: Despliegue de servidor (Clase 32)
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
Django: Despliegue en servidor
    ● Tipos de infraestructuras (IaaS, PaaS, SaaS)
    ● Load Balancer
    ● Python Anywhere
    ● Heroku
    ● Amazon EC2
    ● Docker

----------------------- 
Python Anywhere -> Debemos crear usuario y demás.

render.com


----------------------- Infreastructuras
<IMAGEN> img109

- ¿Donde guardar los archivos?
- ¿Hacer o no backup de los archivos?
- ¿Tener un servicio de git?
- ¿Si va estar todo en el mismo servidor? ¿O aparte? ¿Como se van a conectar?
- ¿Si tendremos servidores comunicados como respaldo o queda offline nuestra página?

- Infrasestructura = Dinero


SAAS -> Software como servicios. Utilizamos el Software. Menos control

PAAS -> Plataforma como servicios. Como Heroku.

IAAS -> Infrasestructura como servicios. Aws, azure, google compute engine. Armamos la estructura.
        * Es mayor el control que podemos usar, tenemos que armar una maquina virtual, colocarle un sistema operativo, conectarlo con la base de datos.
        * Pensar la seguridad y demás, o sea, muchos más conocimientos.


----------------------- PAAS
Heroku          


PythonAnywhere  -> Tiene una capa gratuita.
                *  Dejo de proveer postgresssql de manera gratuita, solo mysql.

----------------------- Elastik VeanStalk - EC2(Server), RDS(DB), Files(S3)
<IMAGEN> img110

    - Para armar un servidor de Django.


    EC2 ->  Maquina virtual, para django es mejor linux.
            * Tener replicas.
            - Arriba una capa, el Load Balancer una maquina, que va equilibrando los request.. Balanceando las Cargas.
                                - De esta manera tendremos un response más rápido.

    S3  ->  Servicio de guardado de archivos estáticos.
            Storage Service, se guarda en otro server

    RDS ->  Relation Database, donde guardamos la base de datos.
            Hay capas gratuitas en cada servicio..   FREE TRIAL
            Estan pre definidas.. 


----------------------- ¿Que es DOcker?

Es un software, que maneja contenedores.
Es una maquina virtual ejecutable dentro de otro sistema operativo.

Plataformas -> Kubernetes.

Hace lo que tendríamos hacer en un sistema operativo.
    - Asignar memoria.
    - Configurar puertos.           ->  Son sentencias que luego corren en otros sistemas.
    - Conectar a la base de datos       

Docker es el intermediario..    Y con las sentencias es el plan de acción, para ejecutar todo.
                                Maquina virtual ejecutable adentro de cualquier sistema operativo que posea docker


----------------------- 
Pythonanywhere + Github

Más sencillo para hacer el despliegue de manera automática.
Creamos el Api Token.. Deja activo la instancia para luego utilizarla.

Databases, creamos la instancia de base de datos.

----------------------- 
----------------------- 
 